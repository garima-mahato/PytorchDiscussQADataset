{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pytorch Discuss QA Dataset Data Formats Data Size JSON , Excel 23.923 MB This dataset contains solved questions and answers from Pytorch Discuss . Description The dataset is in JSON format. It has 9,033 entries. It consist of: Property Description id Unique Pytorch Discuss ID source The source of question and answer which is \"pytorch_discuss\" in our case url Link of query post query Question solution Answer for the specified quest solution_has_code True if solution has code otherwise, False query_has_code True if query has code otherwise, False category The category to which the question belongs intent the question title Sample Data [ { \"pytorch_discuss_id\": 61598, \"source\": \"pytorch_discuss\", \"url\": \"https://discuss.pytorch.org/t/pytorch-dqn-tutorial-where-is-autograd/23460\", \"query\": \"<p><a href=\\\"https://pytorch.org/tutorials/intermediate/reinforcement_q_learning.html\\\" class=\\\"onebox\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener\\\">https://pytorch.org/tutorials/intermediate/reinforcement_q_learning.html</a></p>\\n<p>while the comments in the tutorial specify that autograd is used, it is never explicitly declared (that I can see). In supervised learning, the inputs are usually set as input_data = Variable(input_data) and then out = net.forward(data). However, here, Variable is never used. I do see that the loss tensor contains a gradient - but I am not sure where this came from.</p>\\n<p>Another observation, if I set<br>\\nstate_action_values = Variable(state_action_values,requires_grad=True)<br>\\nthen the code will not run - throwing an error on:<br>\\nfor param in policy_net.parameters():<br>\\nparam.grad.data.clamp_(-1, 1)</p>\\n<p>saying that \u2018NoneType\u2019 has no attribute data (where as clearly before adding the Variable code it did\u2026)</p>\\n<p>Any ideas? Why is Variable not necessary here?</p>\", \"solution\": \"<p>I haven\u2019t explored the tutorial in detail, but from what I know <code>state_action_values</code> are the output of the model, and should already require gradients.<br>\\nCould you check it with <code>state_action_values.requires_grad</code>?</p>\\n<p>Also, if you re-wrap a <code>Tensor</code>, it will lose it\u2019s associated computation graph and you are thus detaching it.<br>\\nThat\u2019s the reason, why <code>.grad</code> is empty in the example you\u2019ve posted.</p>\", \"solution_has_code\": true, \"query_has_code\": false, \"category\": \"reinforcement-learning\", \"intent\": \"pytorch dqn tutorial where is autograd\" }, { \"pytorch_discuss_id\": 22771, \"source\": \"pytorch_discuss\", \"url\": \"https://discuss.pytorch.org/t/reinforce-deprecated/9325\", \"query\": \"<p>I\u2019ve being using action.reinforce(reward) for policy gradient based training, but it seems like there\u2019s been a change recently and I get an error stating:</p>\\n<p>File \u201c/opt/conda/envs/pytorch-py35/lib/python3.5/site-packages/torch/autograd/variable.py\u201d, line 209, in reinforce<br>\\nif not isinstance(self.grad_fn, StochasticFunction):<br>\\nNameError: name \u2018StochasticFunction\u2019 is not defined</p>\\n<p>I read <a href=\\\"https://github.com/pytorch/pytorch/issues/3340\\\" rel=\\\"nofollow noopener\\\">on github</a> that .reinforce is being deprecated, and it\u2019s suggested to use torch.distributions.</p>\\n<p>Is there a reason for this change? Reinforce seemed relatively simple and intuitive. It\u2019ll be great if the <a href=\\\"https://github.com/pytorch/examples/blob/master/reinforcement_learning/reinforce.py\\\" rel=\\\"nofollow noopener\\\">reinforce example from pytorch</a> is updated to reflect this change.</p>\", \"solution\": \"<p>If you are on the 0.2 release, <code>reinforce</code> is still available. If you\u2019re on <code>master</code> and have <code>torch.distributions</code> instead, the RL examples should now be as follows: <a href=\\\"https://github.com/pytorch/examples/pull/249\\\" rel=\\\"nofollow noopener\\\">https://github.com/pytorch/examples/pull/249</a></p>\\n<p><code>torch.distributions</code> is much more general and suitable for a larger range of tasks - building the equivalent of <code>reinforce</code> using this is relatively simple (and arguably cleaner as it can be used to create a normal loss function to backpropagate).</p>\", \"solution_has_code\": true, \"query_has_code\": false, \"category\": \"reinforcement-learning\", \"intent\": \"reinforce deprecated\" } ]","title":"Pytorch Discuss QA Dataset"},{"location":"#pytorch-discuss-qa-dataset","text":"Data Formats Data Size JSON , Excel 23.923 MB This dataset contains solved questions and answers from Pytorch Discuss .","title":"Pytorch Discuss QA Dataset"},{"location":"#description","text":"The dataset is in JSON format. It has 9,033 entries. It consist of: Property Description id Unique Pytorch Discuss ID source The source of question and answer which is \"pytorch_discuss\" in our case url Link of query post query Question solution Answer for the specified quest solution_has_code True if solution has code otherwise, False query_has_code True if query has code otherwise, False category The category to which the question belongs intent the question title","title":"Description"},{"location":"#sample-data","text":"[ { \"pytorch_discuss_id\": 61598, \"source\": \"pytorch_discuss\", \"url\": \"https://discuss.pytorch.org/t/pytorch-dqn-tutorial-where-is-autograd/23460\", \"query\": \"<p><a href=\\\"https://pytorch.org/tutorials/intermediate/reinforcement_q_learning.html\\\" class=\\\"onebox\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener\\\">https://pytorch.org/tutorials/intermediate/reinforcement_q_learning.html</a></p>\\n<p>while the comments in the tutorial specify that autograd is used, it is never explicitly declared (that I can see). In supervised learning, the inputs are usually set as input_data = Variable(input_data) and then out = net.forward(data). However, here, Variable is never used. I do see that the loss tensor contains a gradient - but I am not sure where this came from.</p>\\n<p>Another observation, if I set<br>\\nstate_action_values = Variable(state_action_values,requires_grad=True)<br>\\nthen the code will not run - throwing an error on:<br>\\nfor param in policy_net.parameters():<br>\\nparam.grad.data.clamp_(-1, 1)</p>\\n<p>saying that \u2018NoneType\u2019 has no attribute data (where as clearly before adding the Variable code it did\u2026)</p>\\n<p>Any ideas? Why is Variable not necessary here?</p>\", \"solution\": \"<p>I haven\u2019t explored the tutorial in detail, but from what I know <code>state_action_values</code> are the output of the model, and should already require gradients.<br>\\nCould you check it with <code>state_action_values.requires_grad</code>?</p>\\n<p>Also, if you re-wrap a <code>Tensor</code>, it will lose it\u2019s associated computation graph and you are thus detaching it.<br>\\nThat\u2019s the reason, why <code>.grad</code> is empty in the example you\u2019ve posted.</p>\", \"solution_has_code\": true, \"query_has_code\": false, \"category\": \"reinforcement-learning\", \"intent\": \"pytorch dqn tutorial where is autograd\" }, { \"pytorch_discuss_id\": 22771, \"source\": \"pytorch_discuss\", \"url\": \"https://discuss.pytorch.org/t/reinforce-deprecated/9325\", \"query\": \"<p>I\u2019ve being using action.reinforce(reward) for policy gradient based training, but it seems like there\u2019s been a change recently and I get an error stating:</p>\\n<p>File \u201c/opt/conda/envs/pytorch-py35/lib/python3.5/site-packages/torch/autograd/variable.py\u201d, line 209, in reinforce<br>\\nif not isinstance(self.grad_fn, StochasticFunction):<br>\\nNameError: name \u2018StochasticFunction\u2019 is not defined</p>\\n<p>I read <a href=\\\"https://github.com/pytorch/pytorch/issues/3340\\\" rel=\\\"nofollow noopener\\\">on github</a> that .reinforce is being deprecated, and it\u2019s suggested to use torch.distributions.</p>\\n<p>Is there a reason for this change? Reinforce seemed relatively simple and intuitive. It\u2019ll be great if the <a href=\\\"https://github.com/pytorch/examples/blob/master/reinforcement_learning/reinforce.py\\\" rel=\\\"nofollow noopener\\\">reinforce example from pytorch</a> is updated to reflect this change.</p>\", \"solution\": \"<p>If you are on the 0.2 release, <code>reinforce</code> is still available. If you\u2019re on <code>master</code> and have <code>torch.distributions</code> instead, the RL examples should now be as follows: <a href=\\\"https://github.com/pytorch/examples/pull/249\\\" rel=\\\"nofollow noopener\\\">https://github.com/pytorch/examples/pull/249</a></p>\\n<p><code>torch.distributions</code> is much more general and suitable for a larger range of tasks - building the equivalent of <code>reinforce</code> using this is relatively simple (and arguably cleaner as it can be used to create a normal loss function to backpropagate).</p>\", \"solution_has_code\": true, \"query_has_code\": false, \"category\": \"reinforcement-learning\", \"intent\": \"reinforce deprecated\" } ]","title":"Sample Data"},{"location":"crawler/","text":"Classes PytorchDiscussQASpider A Scrapy Web Crawler to crawl pytorch discuss site and scrape solved questions and answers. Methods parse ( self , response ) Parses main page to get categories. Parameters: Name Type Description Default response Response Scrapy response object required Yields Request: Scrapy Request to each category page Source code in pytorchdiscussqadataset\\pytorch_discuss_qa.py def parse ( self , response ): \"\"\"Parses main page to get categories. Args: response (Response): Scrapy response object Yields: Request: Scrapy Request to each category page \"\"\" res = json . loads ( response . body . decode ( 'utf8' )) category_list = res [ \"category_list\" ][ \"categories\" ] for item in category_list : anchor = self . start_url [ 0 ] + \"c/\" + item [ \"slug\" ] + \"/\" + str ( item [ \"id\" ]) + \".json?page=1&solved=yes\" cat = item [ \"slug\" ] if cat not in [ \"site-feedback\" , \"jobs\" ]: yield scrapy . Request ( anchor , callback = self . parse_category_links , cb_kwargs = dict ( category = cat )) parse_category_link_page ( self , response , category , url ) Parses data within a post in the required structure. Parameters: Name Type Description Default response Response response content of url required category string category of post required url string link to post required Yields JSON: structured QA data Source code in pytorchdiscussqadataset\\pytorch_discuss_qa.py def parse_category_link_page ( self , response , category , url ): \"\"\"Parses data within a post in the required structure. Args: response (Response): response content of url category (string): category of post url (string): link to post Yields: JSON: structured QA data \"\"\" qas = {} res = json . loads ( response . body . decode ( 'utf8' )) posts = res [ \"post_stream\" ][ \"posts\" ] posts_df = pd . DataFrame ( posts ) qas [ \"pytorch_discuss_id\" ] = posts [ 0 ][ \"id\" ] qas [ \"source\" ] = \"pytorch_discuss\" qas [ \"url\" ] = url qas [ \"query\" ] = posts [ 0 ][ \"cooked\" ] qas [ \"solution\" ] = posts_df [ posts_df [ \"accepted_answer\" ] == True ][ \"cooked\" ] . values [ 0 ] qas [ \"solution_has_code\" ] = True if \"</code>\" in qas [ \"solution\" ] else False qas [ \"query_has_code\" ] = True if \"</code>\" in qas [ \"query\" ] else False qas [ \"category\" ] = category qas [ \"intent\" ] = \" \" . join ( posts [ 0 ][ \"topic_slug\" ] . split ( \"-\" )) yield qas parse_category_links ( self , response , category ) Parses each category page to get posts. Parameters: Name Type Description Default response Response Scrapy response object required category string category of query required Yields Request: Scrapy Request to each post page Source code in pytorchdiscussqadataset\\pytorch_discuss_qa.py def parse_category_links ( self , response , category ): \"\"\"Parses each category page to get posts. Args: response (Response): Scrapy response object category (string): category of query Yields: Request: Scrapy Request to each post page \"\"\" res = json . loads ( response . body . decode ( 'utf8' )) df = pd . DataFrame ( res [ \"topic_list\" ][ \"topics\" ]) if \"id\" in df . columns . values and \"slug\" in df . columns . values : df [ \"link\" ] = df . apply ( lambda r : self . start_url [ 0 ] + \"t/\" + r [ \"slug\" ] + \"/\" + str ( r [ \"id\" ]), axis = 1 ) links = df [ \"link\" ] . values for link in links : yield scrapy . Request ( link + '.json' , callback = self . parse_category_link_page , cb_kwargs = dict ( category = category , url = link )) if \"more_topics_url\" in res [ \"topic_list\" ] . keys (): more_links = self . start_url [ 0 ] . rstrip ( '/' ) + res [ \"topic_list\" ][ \"more_topics_url\" ] . split ( '?' )[ 0 ] + \".json?\" + res [ \"topic_list\" ][ \"more_topics_url\" ] . split ( '?' )[ 1 ] yield scrapy . Request ( more_links , callback = self . parse_category_links , cb_kwargs = dict ( category = category ))","title":"Crawler"},{"location":"crawler/#pytorch_discuss_qa-classes","text":"","title":"Classes"},{"location":"crawler/#pytorch_discuss_qa.PytorchDiscussQASpider","text":"A Scrapy Web Crawler to crawl pytorch discuss site and scrape solved questions and answers.","title":"PytorchDiscussQASpider"},{"location":"crawler/#pytorch_discuss_qa.PytorchDiscussQASpider-methods","text":"","title":"Methods"}]}